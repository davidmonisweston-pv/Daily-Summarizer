This code is a **Daily Search Summarizer**, a "deep research" dashboard application built in React.

### **What does it do?**

It is designed to automate the process of monitoring specific topics (e.g., "AI Regulation," "Competitor X," "Interest Rates") by combining **web search** with **AI synthesis**.

Here is the core workflow:

1. **Topic Tracking:** You add topics you want to monitor.
2. **Research Profiles:** For each topic, it uses an LLM (Claude in the original code) to generate a "Research Profile." This profile identifies the best sources, specific search terms, key databases, and "voices" to watch for that specific topic.
3. **Refinement:** You can chat with the system to tweak these profiles (e.g., "Don't use Source X, focus more on Source Y").
4. **Automated Searching:** When you click "Search," it doesn't just do a generic Google search. It uses the **Research Profile** to construct specific, targeted queries, filters by date (e.g., "last 24 hours"), and uses the LLM to read the results.
5. **Summarization:** It compiles the findings into a clean, bulleted list with citations, focusing on new developments.

### **Can it be recreated for Gemini?**

**Yes, absolutely.** In fact, Gemini is arguably *better* suited for this because the Google Search grounding is natively integrated into the Gemini API, making the "search" component faster and more accurate than generic tool-use implementations.

I have rewritten the application below to work seamlessly with the **Gemini API**.

### **Gemini-Powered Version**

This version is a fully functional, single-file React application.

* **Zero Setup:** I replaced the proprietary storage with standard `localStorage`.
* **Gemini Integration:** It uses `gemini-2.0-flash` (or `gemini-1.5-flash`) with the native **Google Search Tool** enabled.
* **Security:** It asks for your API key in the UI (stored only in your browser's local storage) so you don't need a backend.

You can run this code in any React environment (like Create React App, Vite, or online sandboxes like CodeSandbox/StackBlitz).

```jsx
import React, { useState, useEffect, useRef } from 'react';
import { Search, Plus, Trash2, RefreshCw, Clock, ChevronDown, ChevronUp, Settings, X, ExternalLink, SkipForward, Timer, Lightbulb, BookOpen, Sparkles, Send, MessageSquare, Key } from 'lucide-react';

// --- UTILITIES ---

// Simple wrapper for LocalStorage to replace the proprietary window.storage
const storage = {
  get: async (key) => {
    const val = localStorage.getItem(key);
    return val ? { value: val } : null;
  },
  set: async (key, value) => {
    localStorage.setItem(key, value);
  },
  delete: async (key) => {
    localStorage.removeItem(key);
  }
};

// Markdown Renderer (Preserved from original)
function MarkdownRenderer({ content }) {
  const renderMarkdown = (text) => {
    if (!text) return null;
    
    let processedText = text
      .replace(/\n\s*([.,;:!?])/g, '$1')
      .replace(/([^.\n])\n(?!\s*[-*#\d]|\s*$)/g, '$1 ')
      .replace(/  +/g, ' ')
      .replace(/([.!?])\s*(?=\n*##)/g, '$1\n\n');
    
    const lines = processedText.split('\n');
    const elements = [];
    let listItems = [];
    let inList = false;
    
    const processInlineFormatting = (line, keyPrefix) => {
      const parts = [];
      let remaining = line;
      let partIndex = 0;
      
      while (remaining.length > 0) {
        const mdLinkMatch = remaining.match(/\[([^\]]+)\]\(([^)]+)\)/);
        const rawUrlMatch = remaining.match(/(https?:\/\/[^\s<>\[\]]+)/);
        const boldMatch = remaining.match(/\*\*([^*]+)\*\*/);
        const italicMatch = remaining.match(/(?<!\*)\*([^*]+)\*(?!\*)/);
        const codeMatch = remaining.match(/`([^`]+)`/);
        
        const matches = [
          mdLinkMatch && { type: 'mdLink', match: mdLinkMatch, index: remaining.indexOf(mdLinkMatch[0]) },
          rawUrlMatch && { type: 'rawUrl', match: rawUrlMatch, index: remaining.indexOf(rawUrlMatch[0]) },
          boldMatch && { type: 'bold', match: boldMatch, index: remaining.indexOf(boldMatch[0]) },
          italicMatch && { type: 'italic', match: italicMatch, index: remaining.indexOf(italicMatch[0]) },
          codeMatch && { type: 'code', match: codeMatch, index: remaining.indexOf(codeMatch[0]) },
        ].filter(Boolean).sort((a, b) => a.index - b.index);
        
        if (matches.length === 0) {
          if (remaining) parts.push(<span key={`${keyPrefix}-${partIndex++}`}>{remaining}</span>);
          break;
        }
        
        const firstMatch = matches[0];
        if (firstMatch.index > 0) {
          parts.push(<span key={`${keyPrefix}-${partIndex++}`}>{remaining.slice(0, firstMatch.index)}</span>);
        }
        
        switch (firstMatch.type) {
          case 'mdLink':
            parts.push(
              <a key={`${keyPrefix}-${partIndex++}`} href={firstMatch.match[2]} target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 underline inline-flex items-center gap-1">
                {firstMatch.match[1]}<ExternalLink className="w-3 h-3" />
              </a>
            );
            remaining = remaining.slice(firstMatch.index + firstMatch.match[0].length);
            break;
          case 'rawUrl':
            parts.push(
              <a key={`${keyPrefix}-${partIndex++}`} href={firstMatch.match[1]} target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 underline inline-flex items-center gap-1 break-all">
                {firstMatch.match[1].length > 50 ? firstMatch.match[1].slice(0, 50) + '...' : firstMatch.match[1]}<ExternalLink className="w-3 h-3 flex-shrink-0" />
              </a>
            );
            remaining = remaining.slice(firstMatch.index + firstMatch.match[0].length);
            break;
          case 'bold':
            parts.push(<strong key={`${keyPrefix}-${partIndex++}`} className="font-semibold text-slate-100">{firstMatch.match[1]}</strong>);
            remaining = remaining.slice(firstMatch.index + firstMatch.match[0].length);
            break;
          case 'italic':
            parts.push(<em key={`${keyPrefix}-${partIndex++}`} className="italic">{firstMatch.match[1]}</em>);
            remaining = remaining.slice(firstMatch.index + firstMatch.match[0].length);
            break;
          case 'code':
            parts.push(<code key={`${keyPrefix}-${partIndex++}`} className="bg-slate-700 px-1.5 py-0.5 rounded text-sm font-mono text-blue-300">{firstMatch.match[1]}</code>);
            remaining = remaining.slice(firstMatch.index + firstMatch.match[0].length);
            break;
        }
      }
      return parts;
    };
    
    const flushList = () => {
      if (listItems.length > 0) {
        elements.push(<ul key={`list-${elements.length}`} className="list-disc list-outside ml-5 space-y-2 my-3">{listItems}</ul>);
        listItems = [];
      }
      inList = false;
    };
    
    lines.forEach((line, index) => {
      const trimmedLine = line.trim();
      if (!trimmedLine) { flushList(); elements.push(<div key={`empty-${index}`} className="h-3" />); return; }
      if (trimmedLine.startsWith('### ')) { flushList(); elements.push(<h3 key={`h3-${index}`} className="text-lg font-semibold text-slate-100 mt-5 mb-2">{processInlineFormatting(trimmedLine.slice(4), `h3-${index}`)}</h3>); return; }
      if (trimmedLine.startsWith('## ')) { flushList(); elements.push(<h2 key={`h2-${index}`} className="text-xl font-semibold text-slate-100 mt-5 mb-2">{processInlineFormatting(trimmedLine.slice(3), `h2-${index}`)}</h2>); return; }
      if (trimmedLine.startsWith('# ')) { flushList(); elements.push(<h1 key={`h1-${index}`} className="text-2xl font-bold text-slate-100 mt-5 mb-2">{processInlineFormatting(trimmedLine.slice(2), `h1-${index}`)}</h1>); return; }
      if (trimmedLine.match(/^[-*•]\s/)) { inList = true; listItems.push(<li key={`li-${index}`} className="text-slate-300 leading-relaxed">{processInlineFormatting(trimmedLine.slice(2), `li-${index}`)}</li>); return; }
      if (trimmedLine.match(/^\d+\.\s/)) { flushList(); const content = trimmedLine.replace(/^\d+\.\s/, ''); elements.push(<div key={`num-${index}`} className="flex gap-2 my-2"><span className="text-slate-500 font-medium">{trimmedLine.match(/^\d+/)[0]}.</span><span className="text-slate-300 leading-relaxed">{processInlineFormatting(content, `num-${index}`)}</span></div>); return; }
      flushList();
      elements.push(<p key={`p-${index}`} className="text-slate-300 my-2 leading-relaxed">{processInlineFormatting(trimmedLine, `p-${index}`)}</p>);
    });
    flushList();
    return elements;
  };
  return <div className="markdown-content">{renderMarkdown(content)}</div>;
}

// --- GEMINI API CLIENT ---

const callGemini = async (apiKey, prompt, systemInstruction = null, useGoogleSearch = false, signal = null) => {
  if (!apiKey) throw new Error("API Key is missing");

  const model = "gemini-2.0-flash"; // Or gemini-1.5-pro-latest
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

  const tools = useGoogleSearch ? [{ google_search: {} }] : [];
  
  const body = {
    contents: [{
      role: "user",
      parts: [{ text: prompt }]
    }],
    generationConfig: {
      temperature: 0.7,
      maxOutputTokens: 4000,
    }
  };

  if (systemInstruction) {
    body.systemInstruction = {
      parts: [{ text: systemInstruction }]
    };
  }

  if (tools.length > 0) {
    body.tools = tools;
  }

  const response = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
    signal
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error?.message || `API error: ${response.status}`);
  }

  const data = await response.json();
  
  // Extract text
  const text = data.candidates?.[0]?.content?.parts?.map(p => p.text).join('') || '';
  
  // Extract grounding metadata (sources) if available to append as citations
  // Gemini automatically handles inline citations often, but we can capture raw links too if needed.
  // For this implementation, we rely on the prompt asking Gemini to format links in Markdown.
  
  return text;
};


export default function DailySearchSummarizer() {
  const [topics, setTopics] = useState([]);
  const [summaries, setSummaries] = useState([]);
  const [researchProfiles, setResearchProfiles] = useState({});
  const [newTopic, setNewTopic] = useState('');
  const [loading, setLoading] = useState(false);
  const [loadingTopic, setLoadingTopic] = useState(null);
  const [generatingProfile, setGeneratingProfile] = useState(null);
  const [initialized, setInitialized] = useState(false);
  const [expandedSummary, setExpandedSummary] = useState(null);
  const [expandedProfile, setExpandedProfile] = useState(null);
  const [searchPeriod, setSearchPeriod] = useState('last week');
  const [profileChatInput, setProfileChatInput] = useState({});
  const [profileChatLoading, setProfileChatLoading] = useState(null);
  const [profileChatHistory, setProfileChatHistory] = useState({});
  const [apiKey, setApiKey] = useState('');
  const [showKeyInput, setShowKeyInput] = useState(false);
  
  // Refs for search queue management
  const [searchProgress, setSearchProgress] = useState({ current: 0, total: 0, currentTopic: '' });
  const [searchQueue, setSearchQueue] = useState([]);
  const [skippedTopics, setSkippedTopics] = useState([]);
  const [elapsedTime, setElapsedTime] = useState(0);
  const abortControllerRef = useRef(null);
  const timerRef = useRef(null);
  const skipActionRef = useRef(null);
  const cancelledRef = useRef(false);

  const periodOptions = [
    { value: 'last 48 hours', label: 'Last 48 hours' },
    { value: 'last week', label: 'Last week' },
    { value: 'last month', label: 'Last month' },
    { value: 'since last search', label: 'Since last search' },
  ];
  
  const getDateRangeText = (period, topic) => {
    const now = new Date();
    let startDate;
    if (period === 'since last search') {
      const lastSearch = summaries.find(s => s.topic === topic && s.status === 'success');
      startDate = lastSearch ? new Date(lastSearch.timestamp) : new Date(now.setDate(now.getDate() - 7));
    } else {
      startDate = new Date(now);
      if (period === 'last 48 hours') startDate.setHours(startDate.getHours() - 48);
      else if (period === 'last week') startDate.setDate(startDate.getDate() - 7);
      else if (period === 'last month') startDate.setMonth(startDate.getMonth() - 1);
    }
    const formatDate = (d) => d.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
    return `from ${formatDate(startDate)} to ${formatDate(new Date())}`;
  };

  useEffect(() => {
    async function loadData() {
      const t = await storage.get('search-topics');
      if (t?.value) setTopics(JSON.parse(t.value));
      
      const s = await storage.get('search-summaries');
      if (s?.value) setSummaries(JSON.parse(s.value));
      
      const rp = await storage.get('research-profiles');
      if (rp?.value) setResearchProfiles(JSON.parse(rp.value));
      
      const k = await storage.get('gemini-api-key');
      if (k?.value) setApiKey(k.value);
      else setShowKeyInput(true);

      setInitialized(true);
    }
    loadData();
  }, []);

  useEffect(() => {
    if (initialized) storage.set('search-topics', JSON.stringify(topics));
  }, [topics, initialized]);

  useEffect(() => {
    if (initialized) storage.set('search-summaries', JSON.stringify(summaries));
  }, [summaries, initialized]);

  useEffect(() => {
    if (initialized) storage.set('research-profiles', JSON.stringify(researchProfiles));
  }, [researchProfiles, initialized]);

  const saveApiKey = (key) => {
    setApiKey(key);
    storage.set('gemini-api-key', key);
    setShowKeyInput(false);
  };

  const addTopic = () => {
    if (newTopic.trim() && !topics.includes(newTopic.trim())) {
      setTopics([...topics, newTopic.trim()]);
      setNewTopic('');
    }
  };

  const removeTopic = (topic) => {
    setTopics(topics.filter(t => t !== topic));
    setSummaries(summaries.filter(s => s.topic !== topic));
    const newProfiles = { ...researchProfiles };
    delete newProfiles[topic];
    setResearchProfiles(newProfiles);
  };

  // --- GEMINI PROMPT LOGIC ---

  const generateResearchProfile = async (topic) => {
    if (!apiKey) return setShowKeyInput(true);
    setGeneratingProfile(topic);
    
    try {
      const systemPrompt = `You are a research strategist. Respond in EXACT JSON format.`;
      const prompt = `I need to set up ongoing monitoring for this topic: "${topic}"

Create a comprehensive research profile. Consider authoritative sources, industry pubs, databases, and key voices.

Respond in this EXACT JSON format (no markdown, just raw JSON):
{
  "sources": [{"name": "Source Name", "url": "https://...", "type": "publication", "description": "Why it matters"}],
  "searchTerms": ["term 1", "term 2"],
  "databases": [{"name": "Database Name", "url": "https://...", "searchStrategy": "How to search"}],
  "keyVoices": [{"name": "Name", "platform": "Twitter/Blog", "handle": "@handle"}],
  "relatedTopics": ["topic 1"],
  "searchTips": "Advice"
}`;

      // We do NOT use search here, just pure LLM knowledge for strategy
      const responseText = await callGemini(apiKey, prompt, systemPrompt, false);
      
      const cleanJson = responseText.replace(/```json\n?|```\n?/g, '').trim();
      const profile = JSON.parse(cleanJson);
      profile.lastUpdated = new Date().toISOString();
      profile.topic = topic;

      setResearchProfiles(prev => ({ ...prev, [topic]: profile }));
    } catch (err) {
      console.error('Failed to generate profile:', err);
      alert(`Error generating profile: ${err.message}`);
    }
    setGeneratingProfile(null);
  };

  const updateProfileViaChat = async (topic, instruction) => {
    const currentProfile = researchProfiles[topic];
    if (!currentProfile) return;
    setProfileChatLoading(topic);
    
    setProfileChatHistory(prev => ({
      ...prev,
      [topic]: [...(prev[topic] || []), { role: 'user', content: instruction, timestamp: new Date().toISOString() }]
    }));
    
    const needsSearch = /\b(search|find|look for|look up|discover|what are|suggest)\b/i.test(instruction);
    
    try {
        const prompt = `Here is the current research profile for "${topic}":
${JSON.stringify(currentProfile)}

User instruction: "${instruction}"

${needsSearch ? 'Use web search if needed to find real URLs.' : 'Do NOT search web, just edit JSON.'}

Respond with ONLY the complete updated JSON profile.`;

      const responseText = await callGemini(apiKey, prompt, "You are a JSON editor.", needsSearch);
      
      // Attempt to extract JSON
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      const cleanJson = jsonMatch ? jsonMatch[0] : responseText.replace(/```json\n?|```\n?/g, '').trim();
      
      const updatedProfile = JSON.parse(cleanJson);
      updatedProfile.lastUpdated = new Date().toISOString();
      updatedProfile.topic = topic;

      setResearchProfiles(prev => ({ ...prev, [topic]: updatedProfile }));
      setProfileChatHistory(prev => ({
        ...prev,
        [topic]: [...(prev[topic] || []), { role: 'assistant', content: "✓ Profile updated", timestamp: new Date().toISOString() }]
      }));
      setProfileChatInput(prev => ({ ...prev, [topic]: '' }));

    } catch (err) {
      setProfileChatHistory(prev => ({
        ...prev,
        [topic]: [...(prev[topic] || []), { role: 'error', content: `Error: ${err.message}`, timestamp: new Date().toISOString() }]
      }));
    }
    setProfileChatLoading(null);
  };

  const searchAndSummarize = async (topic) => {
    if (!apiKey) return setShowKeyInput(true);
    setLoadingTopic(topic);
    
    const controller = new AbortController();
    abortControllerRef.current = controller;
    const timeoutId = setTimeout(() => controller.abort(), 240000); // 4 min timeout
    
    const dateRange = getDateRangeText(searchPeriod, topic);
    const profile = researchProfiles[topic];
    
    // Constructing the Prompt for Gemini with Grounding
    let searchPrompt = `Topic: "${topic}"
Date Range: ${dateRange}

Task: Perform a deep Google Search to find the latest news and developments.
`;

    if (profile) {
      searchPrompt += `
use this Research Strategy:
1. Prioritize these sources: ${profile.sources?.map(s => s.name).join(', ')}.
2. Use these keywords: ${profile.searchTerms?.join(', ')}.
3. Check for updates from: ${profile.keyVoices?.map(v => v.name).join(', ')}.
`;
    }

    searchPrompt += `
Output Format:
Provide 10-15 bullet points of key findings.
- **[Headline]**: Details. [Source Name](URL)
- STRICTLY include a markdown link [Source Name](URL) at the end of every bullet.
- Only include content from the specified date range.
- If no news, state "No significant recent updates found."
`;

    try {
      // Enable Google Search tool for this call
      const summaryText = await callGemini(apiKey, searchPrompt, "You are a news researcher.", true, controller.signal);
      
      clearTimeout(timeoutId);

      const newSummary = {
        id: Date.now(),
        topic,
        summary: summaryText,
        timestamp: new Date().toISOString(),
        status: 'success',
        period: searchPeriod,
        hasProfile: !!profile
      };

      setSummaries(prev => [newSummary, ...prev.filter(s => s.topic !== topic)]);
      setExpandedSummary(newSummary.id);

    } catch (err) {
      clearTimeout(timeoutId);
      if (skipActionRef.current !== 'skip' && skipActionRef.current !== 'later') {
        const failedSummary = {
          id: Date.now(),
          topic,
          summary: null,
          timestamp: new Date().toISOString(),
          status: 'error',
          errorMessage: err.name === 'AbortError' ? 'Timeout' : err.message
        };
        setSummaries(prev => [failedSummary, ...prev.filter(s => s.topic !== topic)]);
      }
    }
    setLoadingTopic(null);
  };

  // --- QUEUE LOGIC (Preserved) ---
  
  useEffect(() => {
    if (loadingTopic) {
      setElapsedTime(0);
      timerRef.current = setInterval(() => setElapsedTime(p => p + 1), 1000);
    } else {
      clearInterval(timerRef.current);
    }
    return () => clearInterval(timerRef.current);
  }, [loadingTopic]);

  const searchAllTopics = async () => {
    setLoading(true);
    setCancelled(false);
    cancelledRef.current = false;
    setSkippedTopics([]);
    
    let queue = [...topics];
    let completed = 0;
    const total = topics.length;
    
    setSearchQueue(queue);
    setSearchProgress({ current: 0, total, currentTopic: '' });
    
    while (queue.length > 0 && !cancelledRef.current) {
      const topic = queue[0];
      skipActionRef.current = null;
      setSearchProgress({ current: completed + 1, total, currentTopic: topic });
      
      await searchAndSummarize(topic);
      
      if (cancelledRef.current) break;
      
      if (skipActionRef.current === 'later') {
        queue = [...queue.slice(1), topic];
      } else if (skipActionRef.current === 'skip') {
        queue = queue.slice(1);
        setSkippedTopics(prev => [...prev, topic]);
      } else {
        queue = queue.slice(1);
        completed++;
      }
      setSearchQueue(queue);
      if (queue.length > 0) await new Promise(r => setTimeout(r, 1000));
    }
    
    setLoading(false);
    setSearchProgress({ current: 0, total: 0, currentTopic: '' });
  };
  
  const cancelSearch = () => {
    setCancelled(true);
    cancelledRef.current = true;
    if (abortControllerRef.current) abortControllerRef.current.abort();
  };

  if (!initialized) return <div className="p-10 text-slate-400">Loading...</div>;

  return (
    <div className="min-h-screen bg-slate-900 text-slate-100 p-6 font-sans">
      <div className="max-w-3xl mx-auto">
        
        {/* API Key Modal */}
        {showKeyInput && (
          <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
            <div className="bg-slate-800 p-6 rounded-xl max-w-md w-full border border-slate-700">
              <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
                <Key className="w-5 h-5 text-blue-400" /> Enter Gemini API Key
              </h2>
              <p className="text-slate-400 text-sm mb-4">
                This tool runs entirely in your browser. Your key is stored in your browser's local storage and used to call Google's Gemini API directly.
              </p>
              <input
                type="password"
                placeholder="AIzaSy..."
                className="w-full bg-slate-900 border border-slate-700 rounded p-2 mb-4 focus:border-blue-500 outline-none"
                onKeyDown={(e) => e.key === 'Enter' && saveApiKey(e.target.value)}
                onChange={(e) => setApiKey(e.target.value)} // Temporary local state
              />
              <div className="flex justify-end gap-2">
                <a 
                  href="https://aistudio.google.com/app/apikey" 
                  target="_blank" 
                  rel="noreferrer"
                  className="px-4 py-2 text-slate-400 text-sm hover:text-white"
                >
                  Get Key
                </a>
                <button 
                  onClick={() => saveApiKey(apiKey)} // uses the state
                  className="bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded text-white"
                >
                  Save & Continue
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Header */}
        <div className="flex items-center justify-between mb-8">
          <div className="flex items-center gap-3">
            <div className="bg-blue-600 p-2 rounded-lg">
              <Search className="w-6 h-6" />
            </div>
            <div>
              <h1 className="text-2xl font-bold">Gemini Search Summarizer</h1>
              <p className="text-slate-400 text-sm">Deep research powered by Google Search & Gemini 2.0</p>
            </div>
          </div>
          <div className="flex gap-2">
            <button
               onClick={() => setShowKeyInput(true)}
               className="text-slate-500 hover:text-blue-400 p-2 rounded-lg transition-colors"
               title="Update API Key"
            >
              <Key className="w-5 h-5" />
            </button>
            <button
              onClick={() => {
                if(confirm('Clear all data?')) {
                  storage.delete('search-topics');
                  storage.delete('search-summaries');
                  storage.delete('research-profiles');
                  window.location.reload();
                }
              }}
              className="text-slate-500 hover:text-red-400 p-2 rounded-lg transition-colors"
              title="Clear all data"
            >
              <Settings className="w-5 h-5" />
            </button>
          </div>
        </div>

        {/* Add Topic */}
        <div className="bg-slate-800 rounded-xl p-4 mb-6">
          <div className="flex gap-2">
            <input
              type="text"
              value={newTopic}
              onChange={(e) => setNewTopic(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && addTopic()}
              placeholder="Add a topic (e.g., Quantum Computing, TSLA Stock)..."
              className="flex-1 bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-slate-100 placeholder-slate-500 focus:outline-none focus:border-blue-500"
            />
            <button onClick={addTopic} disabled={!newTopic.trim()} className="bg-blue-600 hover:bg-blue-700 disabled:opacity-50 px-4 py-2 rounded-lg flex items-center gap-2 transition-colors">
              <Plus className="w-4 h-4" /> Add
            </button>
          </div>
        </div>

        {/* Topics List */}
        {topics.length > 0 && (
          <div className="bg-slate-800 rounded-xl p-4 mb-6">
            <div className="flex items-center justify-between mb-3">
              <h2 className="text-sm font-medium text-slate-400">Monitoring ({topics.length})</h2>
              <div className="flex items-center gap-3">
                <select value={searchPeriod} onChange={(e) => setSearchPeriod(e.target.value)} className="bg-slate-700 border border-slate-600 rounded-lg px-3 py-1.5 text-sm text-slate-100 outline-none">
                  {periodOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
                </select>
                <button
                  onClick={searchAllTopics}
                  disabled={loading}
                  className="bg-green-600 hover:bg-green-700 disabled:opacity-50 px-3 py-1.5 rounded-lg text-sm flex items-center gap-2 transition-colors"
                >
                  <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
                  {loading ? `Searching ${searchProgress.current}/${searchProgress.total}` : 'Search All'}
                </button>
                {loading && (
                  <button onClick={cancelSearch} className="bg-red-600 hover:bg-red-700 px-3 py-1.5 rounded-lg text-sm flex items-center gap-2">
                    <X className="w-4 h-4" /> Stop
                  </button>
                )}
              </div>
            </div>
            
            {loading && searchProgress.total > 0 && (
              <div className="mb-3">
                <div className="h-1 bg-slate-700 rounded-full overflow-hidden">
                  <div className="h-full bg-green-500 transition-all duration-300" style={{ width: `${(searchProgress.current / searchProgress.total) * 100}%` }} />
                </div>
                <p className="text-xs text-slate-400 mt-1 flex justify-between">
                  <span>Searching: {searchProgress.currentTopic}</span>
                  <span className="text-yellow-400">{elapsedTime}s</span>
                </p>
              </div>
            )}
            
            <div className="space-y-2">
              {topics.map((topic) => {
                const profile = researchProfiles[topic];
                const isExpanded = expandedProfile === topic;
                const isLoadingThis = loadingTopic === topic;
                
                return (
                  <div key={topic} className={`rounded-lg overflow-hidden ${isLoadingThis ? 'bg-blue-900/30 border border-blue-700' : 'bg-slate-700'}`}>
                    <div className="px-3 py-2 flex items-center gap-2">
                      <span className="text-sm font-medium flex-1">{topic}</span>
                      
                      {/* Profile Toggle */}
                      <button onClick={() => setExpandedProfile(isExpanded ? null : topic)} className={`transition-colors ${profile ? 'text-purple-400 hover:text-purple-300' : 'text-slate-500 hover:text-purple-400'}`}>
                        {generatingProfile === topic ? <RefreshCw className="w-4 h-4 animate-spin" /> : profile ? <Sparkles className="w-4 h-4" /> : <Lightbulb className="w-4 h-4" />}
                      </button>
                      
                      {/* Search Single */}
                      <button onClick={() => searchAndSummarize(topic)} disabled={isLoadingThis} className="text-slate-400 hover:text-blue-400 disabled:opacity-50">
                        <RefreshCw className={`w-3.5 h-3.5 ${isLoadingThis ? 'animate-spin' : ''}`} />
                      </button>
                      
                      {/* Delete */}
                      <button onClick={() => removeTopic(topic)} disabled={loading} className="text-slate-400 hover:text-red-400 disabled:opacity-50">
                        <X className="w-3.5 h-3.5" />
                      </button>
                    </div>

                    {/* Expanded Profile View */}
                    {isExpanded && (
                      <div className="px-3 pb-3 border-t border-slate-600 bg-slate-750">
                        {!profile ? (
                           <div className="p-3 text-center">
                             <p className="text-xs text-slate-400 mb-2">No research profile yet.</p>
                             <button onClick={() => generateResearchProfile(topic)} className="text-xs bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded">Generate Profile</button>
                           </div>
                        ) : (
                          <div className="mt-3 space-y-3 text-sm">
                             {/* Display Profile Data */}
                             <div className="grid grid-cols-2 gap-2">
                                <div className="bg-slate-800 p-2 rounded">
                                  <h4 className="text-xs font-bold text-purple-400 mb-1">Sources</h4>
                                  <div className="max-h-20 overflow-y-auto">
                                    {profile.sources?.map((s,i) => <div key={i} className="text-xs text-slate-300 truncate">• {s.name}</div>)}
                                  </div>
                                </div>
                                <div className="bg-slate-800 p-2 rounded">
                                  <h4 className="text-xs font-bold text-purple-400 mb-1">Keywords</h4>
                                  <div className="flex flex-wrap gap-1">
                                    {profile.searchTerms?.map((t,i) => <span key={i} className="text-[10px] bg-slate-700 px-1 rounded">{t}</span>)}
                                  </div>
                                </div>
                             </div>
                             
                             {/* Chat Refine */}
                             <div className="flex gap-2 mt-2">
                               <input 
                                 className="flex-1 bg-slate-600 border border-slate-500 rounded px-2 py-1 text-xs outline-none focus:border-purple-500"
                                 placeholder="Refine profile (e.g. 'Add Reddit as a source')"
                                 value={profileChatInput[topic] || ''}
                                 onChange={e => setProfileChatInput({...profileChatInput, [topic]: e.target.value})}
                                 onKeyDown={e => e.key === 'Enter' && updateProfileViaChat(topic, profileChatInput[topic])}
                               />
                               <button onClick={() => updateProfileViaChat(topic, profileChatInput[topic])} disabled={profileChatLoading === topic} className="bg-purple-600 hover:bg-purple-500 px-2 rounded text-white">
                                 {profileChatLoading === topic ? <RefreshCw className="w-3 h-3 animate-spin"/> : <Send className="w-3 h-3"/>}
                               </button>
                             </div>
                             {/* History */}
                             {profileChatHistory[topic]?.slice(-3).map((msg, i) => (
                               <div key={i} className={`text-[10px] ${msg.role === 'user' ? 'text-slate-400' : 'text-purple-300'}`}>
                                 {msg.role === 'user' ? 'You: ' : 'AI: '}{msg.content}
                               </div>
                             ))}
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Summaries Feed */}
        <div className="space-y-4">
          <h2 className="text-lg font-semibold flex items-center gap-2">
            <Clock className="w-5 h-5 text-slate-400" /> Recent Updates
          </h2>
          
          {summaries.length === 0 && (
            <div className="bg-slate-800 rounded-xl p-8 text-center text-slate-500">
              <p>No summaries yet. Add a topic and search!</p>
            </div>
          )}

          {summaries.map((summary) => (
            <div key={summary.id} className={`rounded-xl overflow-hidden ${summary.status === 'error' ? 'bg-red-900/20 border border-red-800/50' : 'bg-slate-800'}`}>
              <button
                onClick={() => setExpandedSummary(expandedSummary === summary.id ? null : summary.id)}
                className="w-full p-4 flex items-center justify-between hover:bg-slate-750 transition-colors"
              >
                <div className="flex items-center gap-3">
                  <span className={`px-2 py-1 rounded text-sm font-medium ${summary.status === 'error' ? 'bg-red-500/20 text-red-300' : 'bg-blue-500/20 text-blue-300'}`}>
                    {summary.topic}
                  </span>
                  <span className="text-slate-500 text-sm">
                    {new Date(summary.timestamp).toLocaleString(undefined, { month: 'short', day: 'numeric', hour: '2-digit', minute:'2-digit'})}
                  </span>
                  {summary.hasProfile && <Sparkles className="w-3 h-3 text-purple-400" />}
                </div>
                {expandedSummary === summary.id ? <ChevronUp className="w-5 h-5 text-slate-400" /> : <ChevronDown className="w-5 h-5 text-slate-400" />}
              </button>
              
              {expandedSummary === summary.id && (
                <div className="px-4 pb-4 border-t border-slate-700 mt-2">
                  {summary.status === 'error' ? (
                     <div className="text-red-400 p-2 text-sm">{summary.errorMessage}</div>
                  ) : (
                     <MarkdownRenderer content={summary.summary} />
                  )}
                </div>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

```